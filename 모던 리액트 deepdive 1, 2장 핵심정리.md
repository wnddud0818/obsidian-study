# 1장: 리액트 개발을 위해 꼭 알아야 할 자바스크립트 핵심 요약 (JavaScript Essentials for React Development)

---

## • 1.1 자바스크립트의 동등 비교

- 자바스크립트의 모든 값은 원시 타입과 객체 타입으로 나뉨.
    
    - **원시 타입**: `boolean`, `null`, `undefined`, `number`, `string`, `symbol`, `bigint`
        
    - **객체 타입**: `object` (배열, 함수, 정규식, 클래스 포함)
        
- **값을 저장하는 방식의 차이**: 원시 타입은 값을 직접 저장하고, 객체 타입은 참조(메모리 주소)를 전달함.
    
- **리액트에서의 동등 비교**:
    
    - `Object.is`는 참조가 다른 객체에 대해 `false`를 반환함.
        
    - 리액트 팀에서 구현한 `shallowEqual`은 객체의 1단계 깊이(1 depth)까지 비교가 가능함.
        
    - 깊은 비교(2단계 이상)를 하지 않는 이유는 성능 저하 때문임.
        
- **중요성**: 자바스크립트의 동등 비교 특성을 이해해야 훅의 의존성 배열, `useMemo`, `useCallback`의 필요성, `React.memo`의 올바른 작동을 이해할 수 있음.
    

## • 1.2 함수

> **함수 정의**: 작업을 수행하거나 값을 계산하는 과정을 하나의 블록으로 감싸 실행 단위로 만든 것임.

- 자바스크립트에서 함수는 **일급 객체**임. 즉, 다른 함수의 매개변수가 되거나 반환값이 될 수 있으며, 변수에 할당도 가능함.
    
- **함수를 정의하는 4가지 방법**: 함수 선언문, 함수 표현식, 화살표 함수, `Function` 생성자
    
- **주의사항**: 함수의 실행 속도와 컴포넌트 렌더링 속도를 매번 계산하는 것은 어려움.
    

## • 1.3 클래스

> **클래스 정의**: 특정한 객체를 반복적으로 만들기 위한 템플릿 개념임.

- **중요성**: 리액트 16.8 버전 이전에는 모든 컴포넌트가 클래스로 작성되었기 때문에, 과거 리액트 코드를 읽고 개선하기 위해 자바스크립트 클래스 작동 방식을 이해하는 것이 필수적임.
    
- 클래스를 이해하면 클래스 컴포넌트의 생명주기, `React.Component`와 `React.PureComponent` 상속, 메서드 차이 등을 이해할 수 있음.
    

## • 1.4 클로저

> **클로저 정의**: "함수와 함수가 선언된 어휘적 환경(Lexical Scope)의 조합"임.

- **중요성**: 함수 컴포넌트의 구조와 작동 방식, 훅의 원리, 의존성 배열 등 함수 컴포넌트의 대부분 기술이 클로저에 의존하고 있음.
    
- **주의할 점**: 클로저는 공짜가 아니며, 불필요하게 메모리를 잡아먹을 수 있으므로 사용에 주의가 필요함.
    

## • 1.5 이벤트 루프와 비동기 통신의 이해

- 자바스크립트는 기본적으로 싱글 스레드에서 동기 방식으로 작동함. 즉, 한 번에 하나의 작업만 처리할 수 있음.
    
- **이벤트 루프**: 호출 스택에 실행 중인 코드가 있는지, 태스크 큐에 대기 중인 함수가 있는지 반복해서 확인하고, 호출 스택이 비면 태스크 큐의 작업을 순차적으로 실행함.
    
- **비동기 작업 처리**: 이벤트 루프를 통해 웹 환경에서는 많은 양의 비동기 작업이 이루어짐.
    
- **중요성**: 비동기 코드의 작동 방식을 이해하면 자바스크립트가 여러 요청을 동시에 처리하고 우선순위를 관리하는 방법을 파악하여 매끄러운 웹 애플리케이션 서비스를 제공할 수 있음.
    

## • 1.6 리액트에서 자주 사용하는 자바스크립트 문법

- **구조 분해 할당**: 배열이나 객체에서 속성 값을 분해하여 변수에 할당하는 문법
    
- **전개 구문**: 배열, 객체 리터럴 등에서 요소를 확장하거나 복사하는 문법
    
- **객체 초기자 (단축 속성명)**: 객체를 선언할 때 키와 값이 동일한 변수가 있으면 간결하게 작성하는 방식
    
- **`Array` 프로토타입의 메서드**: `map`, `filter`, `reduce`, `forEach` 등 배열을 조작하는 데 사용
    
- **삼항 조건 연산자**: 조건에 따라 다른 값을 반환하는 간결한 문법
    

## • 1.7 선택이 아닌 필수, 타입스크립트

> **타입스크립트 정의**: 자바스크립트의 슈퍼셋(Superset)으로, 타입 지정을 통해 코드 빌드 시점에 에러 가능성을 미리 확인할 수 있음.

- **활용법**: `any` 대신 `unknown` 사용, 제네릭(Generic) 활용 등
    
- **성장세**: 웹 개발 분야에서 타입스크립트의 중요성이 커지고 있으며, 깃허브에서 인기 프로그래밍 언어 상위권에 랭크되어 있음.
    
- **중요성**: 타입스크립트를 통해 버그를 쉽게 찾고 코드 품질을 향상시키며, 협업 효율성을 높일 수 있음. 단, 자바스크립트에 대한 충분한 이해가 선행되어야 함.
    

---

# 2장: 리액트 핵심 요소 깊게 살펴보기 (Deep Dive into React Core Elements)

---

## • 2.1 JSX 란?

> **JSX 정의**: XML과 유사한 내장형 구문으로, 리액트가 등장하면서 페이스북(현 메타)에서 소개했지만 반드시 리액트에 종속적이지 않은 독자적인 문법임. 자바스크립트 표준(ECMAScript)의 일부는 아님.

- **JSX 예제**: `<A>안녕하세요.</A>`, `<A />`, `<A {...{ required: true }} />`, `<A required />`, `<A required={false} />` 등 다양한 형태로 구성됨.
    
- **변환 과정**: JSX는 Babel과 같은 도구를 통해 `React.createElement` 호출로 변환됨.
    
- **논쟁**: HTML 문법과 자바스크립트 문법이 뒤섞여 코드 가독성을 해친다는 비판도 있음.
    

## • 2.2 가상 DOM과 리액트 파이버

- **DOM과 브라우저 렌더링 과정**: 브라우저는 HTML 파싱(DOM 트리 생성), CSS 파싱(CSSOM 생성) 후 이 정보를 바탕으로 렌더링을 수행함. 이 과정은 복잡하고 많은 비용이 듦.
    
- **가상 DOM의 탄생 배경**:
    
    - 브라우저 렌더링 작업은 복잡하고 많은 비용을 소모함.
        
    - 싱글 페이지 애플리케이션(SPA)에서는 잦은 DOM 변경으로 인해 비용 부담이 큼.
        
    - 개발자가 모든 DOM 변경 사항을 수동으로 추적하고 관리하는 것이 어려움.
        
    - 가상 DOM은 이러한 문제를 해결하고, 최종 결과물만 실제 DOM에 적용하여 성능과 개발 편의성을 높이기 위해 등장했음.
        
- **리액트 파이버**: 과거 동기적으로 작동하여 비효율적이었던 리액트의 조정 알고리즘(스택 알고리즘)의 한계를 극복하기 위해 탄생한 새로운 아키텍처임.
    
    - 파이버는 하나의 작업 단위로 구성되며, 이 작업 단위를 유연하게 처리함 (우선순위 지정, 중지, 버리기 등).
        
    - 파이버는 리액트 컴포넌트에 대한 1:1 정보를 가지고 있는 자바스크립트 객체임.
        
    - 작동 순서: `beginWork()` → `completeWork()` → `commitWork()`
        
- **파이버와 가상 DOM의 관계**: 파이버는 가상 DOM을 구현하기 위한 리액트의 내부 개념으로, 브라우저 환경이 아닌 `React Native`와 같은 환경에서도 사용될 수 있음.
    

## • 2.3 클래스 컴포넌트와 함수 컴포넌트

- **클래스 컴포넌트**: `state`와 `setState`, 생명주기(mount, update, unmount) 메서드를 통해 컴포넌트의 상태와 동작을 관리했음.
    
    - `React.PureComponent`는 `state`와 `props`에 대한 얕은 비교를 통해 렌더링 최적화를 수행함.
        
    - **한계**: 데이터 흐름 추적의 어려움, 로직 재사용의 어려움, 핫 리로딩에 불리함 등
        
- **함수 컴포넌트**: 리액트 16.8에서 **훅(Hook)**이 등장하면서 함수 컴포넌트에서도 `state` 관리 및 생명주기 메서드와 유사한 동작 구현이 가능해졌음.
    
    - 함수 컴포넌트는 클로저에 상태를 저장하므로 핫 리로딩 시에도 상태가 유지됨.
        
- **주요 차이점**:
    
    - **생명주기 메서드의 부재**: 함수 컴포넌트에는 클래스 컴포넌트와 같은 명시적인 생명주기 메서드가 없음.
        
    - **간결성**: 함수 컴포넌트가 더 간결하게 작성될 수 있음.
        
    - **핫 리로딩**: 함수 컴포넌트가 클래스 컴포넌트보다 핫 리로딩에 유리함.
        
- **권장 사항**: 새로운 프로젝트는 함수 컴포넌트로 시작하고, 클래스 컴포넌트도 과거 코드 이해 및 일부 에러 처리 기능(React 18 이전)을 위해 학습하는 것이 좋음.
    

## • 2.4 렌더링은 어떻게 일어나는가?

> **리액트 렌더링 정의**: 리액트 애플리케이션 트리의 모든 컴포넌트가 현재 `props`와 `state` 값을 기반으로 UI를 구성하고 DOM 결과를 계산하는 일련의 과정임. 브라우저 렌더링과 혼동하지 않아야 함.

- **렌더링 발생 시나리오**:
    
    - **최초 렌더링**: 사용자가 애플리케이션에 처음 진입할 때.
        
    - **리렌더링**: 최초 렌더링 이후 발생하는 모든 렌더링으로, `setState`, `forceUpdate` 호출, `props`나 `Context` 변경, 부모 컴포넌트 렌더링 시 발생함.
        
- **리액트 렌더링 프로세스**:
    
    - **렌더 단계 (Render Phase)**: 컴포넌트를 렌더링하고 `type`, `props`, `key` 등을 비교하여 변경이 필요한 컴포넌트를 계산하는 단계임. 사용자에게는 노출되지 않는 비동기 작업이 수행됨.
        
    - **커밋 단계 (Commit Phase)**: 렌더 단계의 변경 사항을 실제 DOM에 적용하여 사용자에게 보여주는 단계임. 이 단계가 끝나야 브라우저 렌더링이 발생함.
        
- **동시성 렌더링 (React 18)**: 렌더 단계가 비동기로 작동하여 특정 렌더링의 우선순위를 낮추거나, 중단, 재시작, 포기할 수 있게 됨. 이를 통해 브라우저의 동기 작업을 차단하지 않고 매끄러운 사용자 경험을 제공할 수 있음.
    
- `React.memo`: `props`가 변경되지 않으면 렌더링을 생략하여 불필요한 리렌더링을 막음.
    

## • 2.5 컴포넌트와 함수의 무거운 연산을 기억해 두는 메모이제이션

- **목적**: 리액트에서 발생하는 렌더링을 최소화하기 위해 `useMemo`, `useCallback`, `memo`와 같은 메모이제이션 기법을 사용함.
    
- **오랜 논쟁**:
    
    - **주장 1**: "**섣부른 최적화는 독이다 (premature optimization)**". 메모이제이션에도 비용(값 비교, 결과물 저장)이 들므로, 가벼운 작업에 적용하면 오히려 성능에 역효과를 줄 수 있음. 필요한 곳에만 신중하게 추가해야 함.
        
    - **주장 2**: "**렌더링 과정의 비용은 비싸다, 모조리 메모이제이션해 버리자**". 메모이제이션을 하지 않을 때 발생할 수 있는 잠재적 위험(불필요한 렌더링, 복잡한 로직 재실행, 자식 컴포넌트 렌더링 등)이 더 크다고 주장함.
        
- **결론**:
    
    - 리액트를 깊이 이해하고 시간을 투자할 여유가 있다면, 성능 프로파일러(예: 크롬 개발자 도구)를 활용하여 실제 병목 지점을 확인하고 필요한 곳에만 메모이제이션을 적용하는 것을 권장함.
        
    - 실무 환경에서 판단이 어렵고 최적화에 대한 확신이 없다면, 가능한 한 모든 곳에 메모이제이션을 활용한 최적화를 고려하는 것이 위험 비용 측면에서 더 이점을 누릴 수 있음.