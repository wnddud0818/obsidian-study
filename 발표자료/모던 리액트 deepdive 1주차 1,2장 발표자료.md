### **모던 리액트 deepdive 1장**

#### **(슬라이드 1: 표지)**

안녕하세요! 오늘 모던 리액트 deepdive 1장 주제로 발표를 맡은 박중영입니다. 이 시간에는 리액트 개발의 기반이 되는 자바스크립트의 핵심 개념부터 리액트의 내부 동작 원리까지 깊이 있게 살펴보겠습니다.
리액트의 역사와 들어가며 부분은 저번시간에 했으니, 제외하고 1장부터 바로 들어가도록 하겠습니다.

### **1장: 리액트 개발을 위해 꼭 알아야 할 자바스크립트**

#### **(슬라이드 2: 1.1 자바스크립트의 동등 비교)**

첫 번째로 자바스크립트의 **동등 비교**입니다. 자바스크립트의 모든 값은 **원시 타입**과 **객체 타입**으로 나뉩니다.

- **원시 타입**은 불변하는 값 자체를 저장하지만,
    
- **객체 타입**은 값이 저장된 메모리 주소, 즉 **참조**를 저장합니다.
    

이 차이 때문에 리액트에서는 두 객체가 보기엔 같아 보여도, 참조가 다르면 `false`로 판단합니다. 이것이 바로 우리가 `useMemo`나 `useCallback` 같은 훅을 사용해 의존성 배열을 관리하고, `React.memo`로 불필요한 렌더링을 막아야 하는 근본적인 이유입니다. 자바스크립트의 동등 비교 방식을 이해하는 것이 리액트 최적화의 첫걸음입니다.

#### **(슬라이드 3: 1.2 함수와 1.3 클래스)**

다음은 **함수**와 **클래스**입니다.

자바스크립트에서 **함수**는 **일급 객체**입니다. 즉, 변수에 할당하거나 다른 함수의 인자로 전달하고, 심지어 반환 값으로도 사용할 수 있는 아주 유연한 존재입니다. 오늘날 리액트 개발은 사실상 함수를 다루는 기술이라고 해도 과언이 아닙니다.

**클래스**는 객체를 만드는 '설계도' 또는 '템플릿'입니다. 리액트 훅이 등장하기 전인 16.8 버전 이전에는 모든 컴포넌트가 클래스로 작성되었습니다. 따라서 과거 코드를 유지보수하거나 클래스 기반 라이브러리를 이해하려면, 클래스의 작동 방식과 생명주기 메서드에 대한 이해가 필수적입니다.

#### **(슬라이드 4: 1.4 클로저)**

이번엔 **클로저(Closure)**입니다. 클로저는 "함수와 그 함수가 선언된 환경의 조합"이라는 다소 어려운 정의를 가지고 있습니다.

쉽게 말해, 함수가 자신이 생성된 환경의 변수들을 기억하고 계속 접근할 수 있는 능력입니다. 리액트의 **함수 컴포넌트**가 상태를 유지하고, **훅**이 독립적으로 동작할 수 있는 핵심 원리가 바로 이 클로저 덕분입니다. 리액트 함수 컴포넌트의 마법은 클로저로부터 시작된다고 할 수 있습니다. 다만, 클로저는 메모리를 계속 차지하므로 불필요한 사용은 주의해야 합니다.

#### **(슬라이드 5: 1.5 이벤트 루프와 비동기 통신)**

자바스크립트는 한 번에 하나의 작업만 처리하는 **싱글 스레드** 언어입니다. 하지만 웹 애플리케이션은 사용자 인터랙션, 데이터 요청 등 수많은 작업을 동시에 처리해야 하죠. 어떻게 이게 가능할까요?

바로 **이벤트 루프** 덕분입니다. 이벤트 루프는 '호출 스택'이 비었는지 계속 확인하다가, '태스크 큐'에 대기 중인 작업이 있으면 순서대로 가져와 실행합니다. 이 구조를 통해 자바스크립트는 비동기 작업을 효율적으로 처리하고, 멈춤 없이 매끄러운 사용자 경험을 제공할 수 있습니다.

#### **(슬라이드 6: 1.6 자주 쓰는 문법과 1.7 타입스크립트)**

리액트 코드에서는 특정 자바스크립트 문법이 아주 빈번하게 사용됩니다.

- 객체나 배열에서 값을 쉽게 꺼내는 **구조 분해 할당**,
    
- 불변성을 지키며 배열이나 객체를 복사하는 **전개 구문**,
    
- 그리고 `map`, `filter` 같은 **배열 메서드**들은 이제 리액트 개발의 필수 도구입니다.
    

여기에 더해, **타입스크립트**는 더 이상 선택이 아닌 필수가 되어가고 있습니다. 타입스크립트는 코드 실행 전에 미리 타입을 검사하여 버그를 줄여주고, 코드의 안정성과 협업 효율성을 크게 높여줍니다. 자바스크립트를 충분히 이해한 뒤 타입스크립트를 도입한다면 개발 품질을 한 단계 끌어올릴 수 있습니다.

### **2장: 리액트 핵심 요소 깊게 살펴보기**

#### **(슬라이드 7: 2.1 JSX)**

2장에서는 리액트의 핵심 요소를 더 깊게 들여다보겠습니다. 먼저 **JSX**입니다.

JSX는 HTML처럼 보이지만 실제로는 자바스크립트의 확장 문법입니다. 우리가 작성한 JSX 코드는 Babel과 같은 도구를 통해 `React.createElement`라는 자바스크립트 함수 호출로 변환됩니다. 이 변환 과정을 거쳐 최종적으로 리액트가 이해할 수 있는 객체 형태가 되는 것이죠. 즉, 우리는 JSX를 통해 선언적으로 UI를 작성하지만, 내부적으로는 자바스크립트 코드로 동작하는 것입니다.

#### **(슬라이드 8: 2.2 가상 DOM과 리액트 파이버)**

리액트 성능의 핵심, **가상 DOM(Virtual DOM)**에 대해 알아보겠습니다.

브라우저가 실제 DOM을 변경하는 작업은 매우 복잡하고 비용이 많이 듭니다. 특히 잦은 업데이트가 발생하는 SPA 환경에서는 성능 저하의 주된 원인이 되죠.

**가상 DOM**은 이러한 문제를 해결하기 위해 등장했습니다. 실제 DOM을 직접 건드리는 대신, 메모리상에 존재하는 가상의 DOM 트리를 먼저 변경하고, 이전 버전과 비교하여 변경된 부분만 찾아내 실제 DOM에 **한 번에** 적용합니다. 이를 통해 불필요한 렌더링을 최소화하고 성능을 최적화합니다.

그리고 이 가상 DOM을 효율적으로 관리하고 업데이트하기 위한 새로운 엔진이 바로 **리액트 파이버(React Fiber)**입니다.

#### **(슬라이드 9: 2.2 리액트 파이버의 역할)**

과거 리액트는 업데이트 작업을 동기적으로 처리해서, 복잡한 작업이 시작되면 사용자가 화면이 멈추는 현상을 겪어야 했습니다.

**리액트 파이버**는 이러한 문제를 해결하기 위해 도입된 새로운 아키텍처입니다. 파이버는 렌더링 작업을 여러 개의 작은 '작업 단위'로 나눕니다. 그리고 각 작업에 우선순위를 부여하고, 필요에 따라 작업을 중단하거나 재시작할 수 있게 해줍니다. 덕분에 긴급한 사용자 입력이나 애니메이션을 먼저 처리하여 훨씬 부드러운 사용자 경험을 제공할 수 있게 되었습니다.

#### **(슬라이드 10: 2.3 클래스 컴포넌트와 함수 컴포넌트)**

리액트에는 두 가지 종류의 컴포넌트가 있습니다. 바로 **클래스 컴포넌트**와 **함수 컴포넌트**입니다.

과거에는 `state` 관리와 생명주기 기능을 위해 클래스 컴포넌트를 사용해야 했습니다. 하지만 리액트 16.8 버전에 **훅(Hook)**이 도입되면서 함수 컴포넌트에서도 이 모든 기능이 가능해졌습니다.

함수 컴포넌트는 코드가 더 간결하고, 로직 재사용이 쉬우며, 핫 리로딩에도 유리하다는 장점이 있습니다. 현재 리액트 공식 문서에서도 새로운 프로젝트는 **함수 컴포넌트와 훅을 사용할 것을 권장**하고 있습니다.

#### **(슬라이드 11: 2.4 렌더링은 어떻게 일어나는가?)**

'렌더링'이라는 말을 많이 쓰는데, 리액트의 렌더링은 정확히 무엇일까요?

**리액트 렌더링**이란, 컴포넌트가 현재의 `props`와 `state`를 기반으로 어떻게 UI가 보여야 하는지를 계산하는 과정입니다. 브라우저가 화면을 그리는 실제 렌더링과는 다른, 리액트 내부의 계산 단계입니다.

이 과정은 크게 두 단계로 나뉩니다.

1. **렌더 단계(Render Phase)**: 변경이 필요한 컴포넌트를 파악하는 계산 단계입니다. 이 단계는 비동기적으로 작동하며, 중단될 수도 있습니다.
    
2. **커밋 단계(Commit Phase)**: 계산된 변경 사항을 실제 DOM에 적용하는 단계입니다. 이 단계는 동기적으로 일어나며, 중단되지 않습니다.
    

리액트 18의 **동시성 렌더링**은 바로 이 렌더 단계를 비동기로 만들어, 렌더링 도중에도 사용자 입력에 반응할 수 있게 해주는 핵심 기능입니다.

#### **(슬라이드 12: 2.5 메모이제이션과 오랜 논쟁)**

마지막으로 **메모이제이션(Memoization)**입니다. 메모이제이션은 비용이 큰 연산의 결과를 저장해두고, 동일한 입력이 들어왔을 때 계산 없이 저장된 결과를 즉시 반환하는 최적화 기법입니다. 리액트에서는 `useMemo`, `useCallback`, `React.memo`가 대표적입니다.

하지만 메모이제이션을 언제 얼마나 사용해야 하는지에 대해서는 오랜 논쟁이 있습니다.

- **"섣부른 최적화는 독이다"** 라는 주장이 있습니다. 메모이제이션 자체에도 비교와 저장에 비용이 들기 때문에, 무분별하게 사용하면 오히려 성능이 저하될 수 있다는 것입니다.
    
- 반면, **"일단 전부 메모이제이션 하자"** 는 주장도 있습니다. 렌더링 비용이 워낙 비싸고, 최적화 누락으로 인한 잠재적 위험이 더 크다는 관점입니다.
    

#### **(슬라이드 13: 2.5 메모이제이션 결론)**

그렇다면 우리는 어떻게 해야 할까요?

가장 이상적인 방법은 **성능 프로파일러**를 사용해 실제 병목 지점을 정확히 찾아내고, 그곳에만 최적화를 적용하는 것입니다.

하지만 현실적으로 모든 부분을 측정하기 어렵고, 특히 프로젝트 규모가 커질수록 복잡해집니다. 따라서 실무 환경에서는, **"최적화로 인한 위험보다 최적화를 하지 않았을 때의 위험이 더 클 수 있다"**는 점을 고려하여, 의심스러운 부분에는 적극적으로 메모이제이션을 적용하는 것이 더 안전한 전략이 될 수 있습니다. 중요한 것은 팀의 컨벤션을 정하고 일관성 있게 따르는 것입니다.
