# # React 기초 개념

**사용자 인터페이스(UI)를 만들기 위한 JavaScript 라이브러리**

### **슬라이드 1: 제목**

# React 기초 개념

> 사용자 인터페이스(UI)를 만들기 위한 JavaScript 라이브러리

### **슬라이드 2: React란 무엇인가?**

## **React란?**

- **JavaScript 라이브러리**: 사용자 인터페이스(UI)를 만드는 데 집중합니다. (프레임워크가 아님)
    
- **페이스북(Meta) 제작**: 2013년 처음 출시되어 현재까지 활발하게 유지보수되고 있습니다.
    
- **선언형(Declarative)**: "어떻게"가 아닌 "무엇을" 그릴지 코드로 표현하여 가독성과 예측 가능성을 높입니다.
    
- **컴포넌트 기반(Component-Based)**: 재사용 가능한 UI 조각(컴포넌트)을 만들어 조립하는 방식입니다.
    

### **슬라이드 3: 왜 React를 사용하는가?**

## **React의 핵심 장점**

- **컴포넌트 기반 아키텍처 (CBA)**
    
    - UI를 독립적이고 재사용 가능한 '레고 블록'처럼 만듭니다.
        
    - 코드의 재사용성이 높아지고 유지보수가 용이해집니다.
        
- **가상 DOM (Virtual DOM)**
    
    - 변화가 생기면 실제 DOM이 아닌 가상 DOM에 먼저 변경 사항을 적용합니다.
        
    - 이전 가상 DOM과 비교하여 변경된 부분만 실제 DOM에 반영하여 성능을 최적화합니다.
        
- **선언형 문법**
    
    - `if (조건) { A를 보여줘 } else { B를 보여줘 }` 와 같이, 상태(State)에 따라 UI가 어떻게 보일지 직관적으로 작성할 수 있습니다.
        
- **거대한 생태계와 커뮤니티**
    
    - 라우팅(React Router), 상태 관리(Redux, Zustand), UI 라이브러리(Material-UI) 등 수많은 도구와 자료가 존재합니다.
        

### **슬라이드 4: 핵심 개념 1 - JSX**

## **JSX (JavaScript XML)**

- JavaScript를 확장한 문법으로, JavaScript 코드 안에서 HTML과 유사한 형태로 UI를 작성할 수 있습니다.
    
- 브라우저가 직접 읽을 수 없으므로, 바벨(Babel)을 통해 일반 JavaScript 코드로 변환됩니다.
    

**기존 JavaScript 방식**

```
React.createElement('h1', {className: 'greeting'}, 'Hello, world!');
```

**JSX 방식**

```
const element = <h1 className="greeting">Hello, world!</h1>;
```

**특징**

- JavaScript 표현식을 `{}` 안에 사용할 수 있습니다. `<h1>{name}님, 환영합니다!</h1>`
    
- 반드시 하나의 부모 요소로 감싸야 합니다. (`<div>` 또는 `<>...</>`)
    

### **슬라이드 5: 핵심 개념 2 - 컴포넌트(Component)**

## **컴포넌트 (Component)**

- React 앱을 구성하는 가장 기본적이고 독립적인 단위입니다.
    
- 기능적으로나 시각적으로 분리된 UI 조각입니다.
    
- 현대 React에서는 주로 함수 컴포넌트를 사용합니다.
    

**함수 컴포넌트 예시**

```
// Welcome.js
function Welcome(props) {
  return <h1>Hello, {props.name}</h1>;
}

// App.js
function App() {
  return (
    <div>
      <Welcome name="Sara" />
      <Welcome name="Cahal" />
      <Welcome name="Edite" />
    </div>
  );
}
```

### **슬라이드 6: 핵심 개념 3 - 프롭스(Props)**

## **프롭스 (Properties)**

- 부모 컴포넌트에서 자식 컴포넌트로 데이터를 전달하는 **읽기 전용** 데이터입니다.
    
- 컴포넌트의 재사용성을 높여주는 핵심적인 속성입니다.
    

**작동 방식**

- **부모 컴포넌트 (App)**: `<Welcome name="Sara" />` 와 같이 속성을 설정하여 데이터를 전달합니다.
    
- **자식 컴포넌트 (Welcome)**: `props` 라는 객체로 데이터를 받습니다. (`props.name`)
    

```
// 자식 컴포넌트
function Welcome(props) { // props 객체를 인자로 받음
  // props.name은 "Sara"라는 값을 가짐
  return <h1>Hello, {props.name}</h1>;
}
```

- **중요**: 자식 컴포넌트는 전달받은 props를 직접 수정할 수 없습니다. (Immutable)
    

### **슬라이드 7: 핵심 개념 4 - 상태(State)와 useState**

## **상태 (State) & useState**

- 컴포넌트가 자체적으로 관리하는 데이터입니다. props와 달리 컴포넌트 내부에서 변경될 수 있습니다.
    
- State가 변경되면, 컴포넌트는 자동으로 다시 렌더링(re-rendering)됩니다.
    
- `useState`는 함수 컴포넌트에서 State를 사용할 수 있게 해주는 React Hook입니다.
    

**카운터 예시**

```
import React, { useState } from 'react';

function Counter() {
  // useState(초기값) -> [현재 상태, 상태를 변경할 함수]
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>You clicked {count} times</p>
      {/* setCount 함수를 호출하여 count 상태를 변경 */}
      <button onClick={() => setCount(count + 1)}>
        Click me
      </button>
    </div>
  );
}
```

### **슬라이드 8: 핵심 개념 5 - 이벤트 처리(Event Handling)**

## **이벤트 처리 (Event Handling)**

- 사용자의 행동(클릭, 입력 등)에 반응하여 특정 코드를 실행하는 것입니다.
    
- React의 이벤트는 HTML과 유사하지만, **camelCase**로 작성합니다. (예: `onclick` -> `onClick`)
    
- 이벤트 핸들러에는 함수를 직접 전달합니다.
    

**예시**

```
function Button() {
  function handleClick() {
    alert('버튼이 클릭되었습니다!');
  }

  // onClick 이벤트에 handleClick 함수를 연결
  return (
    <button onClick={handleClick}>
      클릭하세요
    </button>
  );
}

// 화살표 함수로 인라인 작성도 가능
<button onClick={() => console.log('클릭됨!')}>클릭</button>
```

### **슬라이드 9: 리스트 렌더링 - map()과 key**

## **리스트와 Key**

- 배열의 각 요소를 순회하며 컴포넌트나 엘리먼트 리스트를 생성할 때 JavaScript의 `map()` 함수를 주로 사용합니다.
    
- **key**: `map()`을 사용할 때 각 리스트 아이템에 고유한 `key` prop을 반드시 지정해야 합니다.
    

**왜 key가 필요한가?**

- React가 어떤 항목이 변경, 추가 또는 삭제되었는지 식별하는 데 도움을 줍니다.
    
- key는 형제 요소들 사이에서만 고유하면 됩니다.
    

**예시**

```
function NumberList({ numbers }) {
  const listItems = numbers.map((number) =>
    // 배열의 각 요소에 고유한 key를 지정합니다.
    <li key={number.toString()}>
      {number}
    </li>
  );

  return <ul>{listItems}</ul>;
}

const numbers = [1, 2, 3, 4, 5];
// <NumberList numbers={numbers} />
```